package de.calamanari.other;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The holder keeps the state during reformatting a singl code-html-file generated by javadoc.
 * 
 * @author <a href="mailto:Karl.Eilebrecht(a/t)calamanari.de">Karl Eilebrecht</a>
 *
 */
public class JavaDocSourceHolder {

    private static final String PK_PROCESSED = "<!-- pk:processed -->";

    // the Sonar Lint warning is correct, but the input (import statement line) is very short, so leaving the expression as is
    @SuppressWarnings("java:S5998")
    private static final String IMPORT_SEARCH_PATTERN_2 = "^\\s*(import\\s+)?((\\w+\\.)+\\w+)(\\.\\*)?(\\s*;\\s*)?$";

    private final List<FileLine> lines;

    private final int sourceLinesStart;
    private final int sourceLinesEnd;

    public final Path path;

    public final String className;

    public final String simpleClassName;

    public final String[] packagePath;

    public final String[] importPackageNames;

    public JavaDocSourceHolder(File baseDir, File file) throws IOException {
        this.path = file.toPath();
        List<String> rawLines = Files.readAllLines(path, StandardCharsets.UTF_8);

        List<FileLine> linesLocal = new ArrayList<>(rawLines.size());
        int firstSourceLine = -1;
        int afterSourceLine = -1;

        int idx = 0;
        for (String line : rawLines) {
            if (isSourceLine(line)) {
                linesLocal.add(new SourceLine(line));
                if (firstSourceLine == -1) {
                    firstSourceLine = idx;
                }
            }
            else {
                linesLocal.add(new FileLine(line));
                if (firstSourceLine > -1 && afterSourceLine == -1) {
                    afterSourceLine = idx;
                }
            }
            idx++;
        }
        this.lines = Collections.unmodifiableList(linesLocal);
        this.sourceLinesStart = firstSourceLine;
        this.sourceLinesEnd = afterSourceLine;

        String baseName = baseDir.getAbsolutePath();
        String fileName = file.getAbsolutePath();
        fileName = fileName.substring(baseName.length() + 1);
        int pos = fileName.lastIndexOf('.');
        fileName = fileName.substring(0, pos);

        pos = fileName.lastIndexOf(File.separatorChar);

        this.className = fileName.replace(File.separatorChar, '.');

        String pkgName = null;
        if (pos > -1) {
            this.simpleClassName = className.substring(pos + 1);
            pkgName = className.substring(0, pos);
            this.packagePath = pkgName.split("[\\.]");
        }
        else {
            this.simpleClassName = className;
            this.packagePath = new String[0];
        }
        this.importPackageNames = extractImportPackageNames(pkgName);
    }

    private String[] extractImportPackageNames(String currentPackage) {
        Matcher matcher = Pattern.compile(IMPORT_SEARCH_PATTERN_2).matcher("");
        List<String> pkgList = new ArrayList<>();
        if (currentPackage != null) {
            pkgList.add(currentPackage);
        }
        for (SourceLine line : getSourceLines()) {
            matcher.reset(line.text.substring(line.startPos, line.endPos));
            if (matcher.find()) {
                String pkgName = matcher.group(2);
                if (!pkgName.startsWith("org.") && !pkgName.startsWith("java.")) {
                    pkgList.add(matcher.group(2));
                }
            }
        }
        return pkgList.toArray(new String[pkgList.size()]);
    }

    private boolean isSourceLine(String rawLine) {
        return rawLine.indexOf("<span class=\"source-line-no\">") > -1;
    }

    public List<SourceLine> getSourceLines() {
        List<SourceLine> res = Collections.emptyList();
        if (sourceLinesStart > -1) {
            int endIdx = sourceLinesEnd;
            if (endIdx == -1) {
                endIdx = lines.size();
            }
            @SuppressWarnings("unchecked")
            List<SourceLine> subLines = (List<SourceLine>) (Object) lines.subList(sourceLinesStart, endIdx);
            res = subLines;
        }
        return res;
    }

    public void storeFile() throws IOException {
        if (!lines.isEmpty()) {
            FileLine lastLine = lines.get(lines.size() - 1);
            lastLine.text = lastLine.text + PK_PROCESSED;
        }
        Files.write(path, lines, StandardCharsets.UTF_8);
    }

    public boolean isAlreadyProcessed() {
        return lines.stream().anyMatch((FileLine line) -> (line.text.contains(PK_PROCESSED)));
    }
}